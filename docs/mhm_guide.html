<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>MHM User Guide, Version 2.0 (09/30/2020)</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <center><h1>MHM User Guide</h1><h3>Version 2.0 (09/30/2020)</h3></center>
  <center><h1>MHM User Guide</h1><h3>Version 2.0 (09/30/2020)</h3></center>
</head>
<body>
<style type="text/css">

html {
  font-size: 100%;
  overflow-y: scroll;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}

body {
  color: #444;
  font-family: Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman', serif;
  font-size: 12px;
  line-height: 1.7;
  padding: 1em;
  margin: auto;
  max-width: 60em;
  background: #fefefe;
}

a {
  color: #0645ad;
  text-decoration: none;
}

a:visited {
  color: #0b0080;
}

a:hover {
  color: #06e;
}

a:active {
  color: #faa700;
}

a:focus {
  outline: thin dotted;
}

*::-moz-selection {
  background: rgba(255, 255, 0, 0.3);
  color: #000;
}

*::selection {
  background: rgba(255, 255, 0, 0.3);
  color: #000;
}

a::-moz-selection {
  background: rgba(255, 255, 0, 0.3);
  color: #0645ad;
}

a::selection {
  background: rgba(255, 255, 0, 0.3);
  color: #0645ad;
}

p {
  margin: 1em 0;
}

img {
  max-width: 100%;
}

h1, h2, h3, h4, h5, h6 {
  color: #111;
  line-height: 125%;
  margin-top: 2em;
  font-weight: normal;
}

h4, h5, h6 {
  font-weight: bold;
}

h1 {
  font-size: 2em;
}

h2 {
  font-size: 1.8em;
}

h3 {
  font-size: 1.5em;
}

h4 {
  font-size: 1.2em;
}

h5 {
  font-size: 1em;
}

h6 {
  font-size: 0.9em;
}

blockquote {
  color: #666666;
  margin: 0;
  padding-left: 3em;
  border-left: 0.5em #EEE solid;
}

hr {
  display: block;
  height: 2px;
  border: 0;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #eee;
  margin: 1em 0;
  padding: 0;
}

pre, code, kbd, samp {
  color: #000;
  font-family: monospace, monospace;
 _font-family: 'courier new', monospace;
  font-size: 0.9em;
  background-color: #EEEEEE;
}

pre {
  white-space: pre;
  white-space: pre-wrap;
  word-wrap: break-word;
}

b, strong {
  font-weight: bold;
}

dfn {
  font-style: italic;
}

ins {
  background: #ff9;
  color: #000;
  text-decoration: none;
}

mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

sub, sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sup {
  top: -0.5em;
}

sub {
  bottom: -0.25em;
}

ul, ol {
  margin: 1em 0;
  padding: 0 0 0 2em;
}

li p:last-child {
  margin-bottom: 0;
}

ul ul, ol ol {
  margin: .3em 0;
}

dl {
  margin-bottom: 1em;
}

dt {
  font-weight: bold;
  margin-bottom: .8em;
}

dd {
  margin: 0 0 .8em 2em;
}

dd:last-child {
  margin-bottom: 0;
}

#TOC ul {
    list-style-type: none;
}

img {
  border: 0;
  -ms-interpolation-mode: bicubic;
  vertical-align: middle;
}

figure {
  display: block;
  text-align: center;
  margin: 1em 0;
}

figure img {
  border: none;
  margin: 0 auto;
}

figcaption {
  font-size: 1.0em;
  font-style: bold;
  margin: 0 0 .8em;
}

table {
  margin-bottom: 2em;
  border-bottom: 1px solid #ddd;
  border-right: 1px solid #ddd;
  border-spacing: 0;
  border-collapse: collapse;
}

table th {
  padding: .2em 1em;
  background-color: #eee;
  border-top: 1px solid #ddd;
  border-left: 1px solid #ddd;
}

table td {
  padding: .2em 1em;
  border-top: 1px solid #ddd;
  border-left: 1px solid #ddd;
  vertical-align: top;
}

.author {
  font-size: 1.2em;
  text-align: center;
}

@media only screen and (min-width: 480px) {
  body {
    font-size: 14px;
  }
}
@media only screen and (min-width: 768px) {
  body {
    font-size: 16px;
  }
}


@media print {
  {
    background: transparent !important;
    color: black !important;
    filter: none !important;
    -ms-filter: none !important;
  }

  body {
    font-size: 10pt;
    max-width: 100%;
  }

  title {
      font-size: 2em;
  }
  
  a, a:visited {
      text-decoration: none;
      color: #520;
  }

  #TOC {
      page-break-after: always;
      font-size: 12pt;
  }

  #introduction {
      page-break-before: always;
  }
  
  hr {
    height: 1px;
    border: 0;
    border-bottom: 1px solid black;
  }

  a[href]:after {
    content: " (" attr(href) ")";
  }

  abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after {
      content: "";
  }

  pre, blockquote {
      padding-right: 1em;
      padding-left: 2em;
      page-break-inside: avoid;
  }

  tr, img {
    page-break-inside: avoid;
  }

  img {
    max-width: 100% !important;
  }

  @page {
    margin: 15mm 15mm 15mm 15mm;
  }

  p, h2, h3 {
    orphans: 3;
    widows: 3;
  }

  h1, h2, h3 {
      page-break-after: avoid;
  }

  @page :footer {
      content: "Page " decimal(pageno);
      font-variant: small-caps;
  }
}


</style>
<hr />
<p><strong><em>Copyright</em></strong></p>
<p><em>This manuscript has been authored by an author at Lawrence Berkeley National Laboratory under Contract No. DE-AC02-05CH11231 with the U.S. Department of Energy. The U.S. Government retains, and the publisher, by accepting the article for publication, acknowledges, that the U.S. Government retains a non-exclusive, paid-up, irrevocable, world-wide license to publish or reproduce the published form of this manuscript, or allow others to do so, for U.S. Government purposes.</em></p>
<p><strong><em>Legal Disclaimer</em></strong></p>
<p><em>This document was prepared as an account of work sponsored by the United States Government. While this document is believed to contain correct information, neither the United States Government nor any agency thereof, nor the Regents of the University of California, nor any of their employees, makes any warranty, express or implied, or assumes any legal responsibility for the accuracy, completeness, or usefulness of any information, apparatus, product, or process disclosed, or represents that its use would not infringe privately owned rights. Reference herein to any specific commercial product, process, or service by its trade name, trademark, manufacturer, or otherwise, does not necessarily constitute or imply its endorsement, recommendation, or favoring by the United States Government or any agency thereof, or the Regents of the University of California. The views and opinions of authors expressed herein do not necessarily state or reflect those of the United States Government or any agency thereof or the Regents of the University of California.</em></p>
<p><strong><em>Acknowledgments</em></strong></p>
<p><em>This work was supported by the Exascale Computing Project (17-SC-20-SC), a collaborative effort of the U.S. Department of Energy Office of Science and the National Nuclear Security Administration.</em></p>
<hr />

<p>MetaHipMer (<em>MHM</em>) is a <em>de novo</em> metagenome short-read assembler. This document is for version 2 (MHM2), which is written entirely in <a href="https://upcxx.lbl.gov">UPC++</a> and runs efficiently on both single servers and on multinode supercomputers, where it can scale up to coassemble terabase-sized metagenomes. More information about MHM can be found in:</p>
<ul>
<li><a href="https://ieeexplore.ieee.org/document/8665813">E. Georganas et al., “Extreme Scale De Novo Metagenome Assembly,” SC18: International Conference for High Performance Computing, Networking, Storage and Analysis, Dallas, TX, USA, 2018, pp. 122-13.</a></li>
<li><a href="https://www.nature.com/articles/s41598-020-67416-5#citeas">Hofmeyr, S., Egan, R., Georganas, E. et al. Terabase-scale metagenome coassembly with MetaHipMer. Sci Rep 10, 10689 (2020).</a></li>
</ul>
<h1 id="building-and-installing">Building and Installing</h1>
<p>MHM2 depends on UPC++, with the C++17 standard, and CMake. GPU builds require CUDA.</p>
<p>A script, <code>build.sh</code>, is provided for building and installing MHM2.</p>
<p>Before building MHM2, ensure that either the UPC++ compiler wrapper, <code>upcxx</code> is in your <code>PATH</code>, or set the <code>MHM2_BUILD_ENV</code> environment variable to point to a script that loads the appropriate environment, for example, on <a href="https://docs.nersc.gov/systems/cori/">NERSC’s Cori supercomputer</a>, you would set the following for the gnu compiler on the KNL partition:</p>
<p><code>export MHM2_BUILD_ENV=contrib/environments/cori-knl/gnu.sh</code></p>
<p>There are several scripts provided for different build choices on NERC’s Cori computer and the <a href="https://www.olcf.ornl.gov/summit/.">Summit supercomputer at OLCF</a>, in directories that start with <code>contrib/environments</code>. You do not need to use any scripts such as these when building on a Linux server, although you may want to create your own when setting up the build. On Cori, we recommend using either the gnu (<code>contrib/environments/cori-*/gnu.sh</code>) or cray (<code>contrib/environments/cori-*/cray.sh</code>) environments. Building with Intel is very slow.</p>
<p>To build a release version (optimized for performance), execute:</p>
<p><code>./build.sh Release</code></p>
<p>Alternatively, you can build a debug version with:</p>
<p><code>./build.sh Debug</code></p>
<p>This will capture a great deal of information useful for debugging but will run a lot slower (up to 5x slower at scale on multiple nodes).</p>
<p>An alternative to the pure debug version is the “release” debug version, which still captures a reasonable amount of debugging information, but is a lot faster (although still up to 2x slower than the release version):</p>
<p><code>./build.sh RelWithDebInfo</code></p>
<p>The <code>./build.sh</code> script will install the binaries by default into the <code>install/bin</code> subdirectory in the repository root directory. To set a different install directory, set the environment variable <code>MHM2_INSTALL_PATH</code>, e.g.:</p>
<p><code>MHM2_INSTALL_PATH=/usr/local/share/mhm2 ./build.sh Release</code></p>
<p>Once MHM2 has been built once, you can rebuild with</p>
<p><code>./build.sh</code></p>
<p>and it will build using the previously chosen setting (<code>Release</code>, <code>Debug</code>, or <code>RelWithDebInfo</code>).</p>
<p>You can also run</p>
<p><code>./build.sh clean</code></p>
<p>to start from scratch. If you run this, then the next call to <code>build.sh</code> should be with one of the three configuration settings.</p>
<p>By default, the build occurs within the root of the repository, in a subdirectory called <code>.build</code>. This is created automatically by the <code>build.sh</code> script.</p>
<p>The MHM2 build uses <code>cmake</code>, which you can call directly, instead of through the <code>build.sh</code> script, e.g.:</p>
<pre><code>mkdir -p .build
cd .build
cmake -DCMAKE_INSTALL_PREFIX=path-to-install ..
make -j all check install</code></pre>
<p>You’ll need to first set the environment, e.g.:</p>
<p><code>source contrib/environments/cori-knl/gnu.sh</code></p>
<h1 id="running">Running</h1>
<p>To execute MHM2, run the <code>mhm2.py</code> script located at <code>install/bin</code>. Most parameters have sensible defaults, so it is possible to run with only the read FASTQ files specified, e.g. to run with two interleaved reads files, <code>lib1.fastq</code> and <code>lib2.fastq</code>, you could execute:</p>
<p><code>mhm2.py -r lib1.fastq,lib2.fastq</code></p>
<p>A list of all the command line options can be found by running with <code>-h</code>. Some of these have a short form (a single dash with a single character) and a long form (starting with a double-dash). In the options described below, where both a short form and a long form exist, they are separated by a comma. The type of the option is indicated as one of <code>STRING</code> (a string of characters), <code>INT</code> (an integer), <code>FLOAT</code> (a floating point value) or <code>BOOL</code> (a boolean flag). For <code>BOOL</code>, the option can be given as <code>true</code>, <code>false</code>, <code>yes</code>, <code>no</code>, <code>0</code>, <code>1</code>, or omitted altogether, in which case the option will be <code>true</code>, and if an option is specfied, the <code>=</code> must be used, e.g. <code>mhm2.py --checkpoint=false</code></p>
<p>By default, the run will generate files in the output directory (see the <code>--output</code> option below). At a minimum, this will include the following files:</p>
<ul>
<li><code>final_assembly.fasta</code>: the contigs for the assembly, in FASTA format.</li>
<li><code>mhm2.log</code>: a log file containing details about the run, including various quality statistics, details about the assembly process and timing information.</li>
<li><code>mhm2.config</code>: a configuration file containing all the options used for the run.</li>
<li><code>per_thread</code>: a subdirectory containing per-process files that record memory usage and debugging information in Debug mode.</li>
</ul>
<p>In addition, many more files may be generated according to which command-line options are specified. These are described in detail below where relevant.</p>
<h2 id="basic-options">Basic options</h2>
<p>These are the most commonly used options.</p>
<p><strong><code>-r, --reads STRING,STRING,...</code></strong></p>
<p>A collection of names of files containing reads in FASTQ format. Multiple files must be comma-separated, or can be separated by spaces. Currently, only paired reads are supported, and with this option they must be interleaved. For paired reads in separate files, use the <code>-p</code> option. Either this or the <code>-p</code> option are required. For long lists of read files, they can be set in a configuration file, to avoid having to type them in on the command line.</p>
<p>When running on a <a href="https://lustre.org/">Lustre</a> file system (such as on NERSC’s Cori), it is recommended that all input files be <a href="https://wiki.lustre.org/Configuring_Lustre_File_Striping">striped</a> to ensure adequate I/O performance. Usually this means striping a directory and then moving files into it, e.g. for a file <code>reads.fastq</code>:</p>
<pre><code>mkdir data
lfs setstripe -c -1 data
mv reads.fastq data</code></pre>
<p><strong><code>-p, --paired-reads STRING,STRING,...</code></strong></p>
<p>File names for paired reads in FASTQ format contained in separate files. For each library, the file containing the reads for the first pairs must be followed by the file containing the reads for the second pairs, e.g. for two libraries with separate paired reads files <code>lib1_1.fastq</code>, <code>lib1_2.fastq</code> and <code>lib2_1.fastq</code>, <code>lib2_2.fastq</code>, the option should be specified as:</p>
<p><code>-p lib1_1.fastq,lib1_2.fastq,lib2_1.fastq,lib2_2.fastq</code></p>
<p>This option only supports reads where each pair of reads has the same sequence length, usually only seen in raw reads. For support of trimmed reads of possibly different lengths, first interleave the files and then call with the <code>-r</code> option. The separate files can be interleaved with <code>reformat.sh</code> from <a href="https://jgi.doe.gov/data-and-tools/bbtools/">bbtools</a>.</p>
<p><strong><code>-i, --insert INT:INT</code></strong></p>
<p>The insert size for paired reads: the first integer is the average insert size for the paired reads, and the second integer is the standard deviation of the insert sizes. MHM2 will automatically attempt to compute these values so this parameter is usually not necessary. However, there are certain cases where it may be useful, for example, if MHM2 prints a warning about being unable to compute the insert size because of the nature of the reads, or if only doing scaffolding. MHM2 will also compare its computed value to any option set on the command line and print a warning if the two differ significantly; this is useful for confirming assumptions about the insert sise distribution.</p>
<p><strong><code>-k, --kmer-lens INT,INT,...</code></strong></p>
<p>The <em>k</em>-mer lengths used for the contigging rounds. MHM2 performs one or more contigging rounds, each of which performs <em>k</em>-mer counting, followed by a deBruijn graph traversal, then alignment and local assembly to extend the contigs. Typically, multiple rounds are used with increasing values of <em>k</em> - the shorter values are useful for low abundance genomes, whereas the longer <em>k</em> values are useful for resolving repeats. This option defaults to <code>-k 21,33,55,77,99</code>, which is fine for reads of length 150. For shorter or longer reads, it may be a good idea to adjust these values. Also, each round of contigging takes time, so the overall assembly time can be reduced by reducing the number of rounds, although this will likely reduce the quality of the final assembly.</p>
<p><strong><code>-s, --scaff-kmer-lens INT,INT,...</code></strong></p>
<p>The <em>k</em>-mer lengths used for the scaffolding rounds. In MHM2, the contigging rounds are followed by one or more scaffolding rounds. These rounds usually proceed from a high <em>k</em> to a low one, i.e. the reverse ordering of contigging. This option defaults to <code>-s 99,33</code>. More rounds may improve contiguity but will likely increase misassemblies. To disable scaffolding altogether, set this value to 0, i.e. <code>-s 0</code>.</p>
<p><strong><code>--min-ctg-print-len INT</code></strong></p>
<p>The minimum length for contigs to be included in the final assembly, <code>final_assembly.fasta</code>. This defaults to 500.</p>
<p><strong><code>-o, --output STRING</code></strong></p>
<p>The name for the output directory. If not specified, it will be set to a default value of the following form:</p>
<p><code>mhm2-run-&lt;READS_FNAME1&gt;-n&lt;PROCS&gt;-N&lt;NODES&gt;-YYMMDDhhmmss</code></p>
<p>where <code>&lt;READS_FNAME1&gt;</code> is the name of the first reads file, <code>PROCS</code> is the number of processes and <code>NODES</code> is the number of nodes. The final part is the date when the run was started: <code>YY</code> is the year, <code>MM</code> is the number of the month, <code>DD</code> is the day of the month, <code>hh</code> is the hour of day, <code>mm</code> is the minute and <code>ss</code> is the second. Be warned that if two runs are started at exactly the same time, with the same parameters, they could both end up running in the same output directory, which will lead to corrupted results.</p>
<p>If the output directory is created by MHM2 (either as the default or when passed as a parameter), it will automatically be striped in the most effective way on a Lustre filesystem. If using a pre-existing directory that was not created by MHM2, the user should ensure that on Lustre filesystems it is adequately striped.</p>
<p>If the output directory already exists, files produced by a previous run of MHM2 can be overwritten, depending on whether or not this is a restart of a previous run. If there is an existing log file (<code>mhm2.log</code>), it will be renamed with the date before the new one is written as <code>mhm2.log</code>, so log information about previous runs will always be retained.</p>
<p><strong><code>--checkpoint BOOL</code></strong></p>
<p>If set to true, this will checkpoint the run by saving intermediate files that can later be used to restart the run (see the <code>--restart</code> option below). The intermediate files are FASTA files of contigs, and they are saved at three points: halfway through each contigging round (file name <code>uutigs-&lt;k&gt;.fasta</code>), at the end of each contigging round (<code>contigs-&lt;k&gt;.fasta</code>) and at the end of each scaffolding round (<code>scaff-contigs-&lt;k&gt;.fasta</code>), where the <code>&lt;k&gt;</code> value is the <em>k</em>-mer size for that round. Checkpointing is on by default and can be disabled by passing <code>--checkpoint=false</code>.</p>
<p><strong><code>--restart BOOL</code></strong></p>
<p>If set to true, MHM2 will attempt to restart a run from an existing directory. The output directory option must be specified and must contain a previous checkpointed run. The restart will use the same options as the previous run, and will load the most recent checkpointed contigs file in order to resume. This defaults to false.</p>
<p><strong><code>--post-asm-align BOOL</code></strong></p>
<p>If set to true. MHM2 will align the original reads to the final assembly and report the results in a file, <code>final_assembly.sam</code>, in <a href="https://samtools.github.io/hts-specs/SAMv1.pdf">SAM format</a>. This defaults to false.</p>
<p><strong><code>--post-asm-abd BOOL</code></strong></p>
<p>If set to true, MHM2 will compute the abundances (depths) for the contigs in the final assembly and write the results to the file, <code>final_assembly_depths.txt</code>. The format of this file is the same as that used by <a href="https://bitbucket.org/berkeleylab/metabat/">MetaBAT</a>, and so can be used together with the <code>final_assembly.fasta</code> for post-assembly binning, e.g.:</p>
<p><code>metabat2 -i final_assembly.fasta -a final_assembly_depths.txt -o bins_dir/bin</code></p>
<p>This defaults to false.</p>
<p><strong><code>--post-asm-only BOOL</code></strong></p>
<p>If set to true, this requires an existing directory containing a full run (i.e. with a <code>final_assembly.fasta</code> file), and it will execute any specified post-assembly options (<code>--post-asm-align</code> or <code>--post-asm-abd</code>) on that assembly without any other steps. This provides a convenient means to run alignment and/or abundance calculations on an already completed assembly. By default this post-assembly analysis will use the <code>final_assembly.fasta</code> file in the output directory, but any FASTA file could be used, including those not generated by MHM2 (see the <code>--contigs</code> in the advanced options section below). This defaults to false.</p>
<p><strong><code>--write-gfa BOOL</code></strong></p>
<p>If set to true, MHM2 will output an assembly graph in the <a href="https://github.com/GFA-spec/GFA-spec/blob/master/GFA2.md">GFA2 format</a> in file, <code>final_assembly.gfa</code>. This represents the assembly graph formed by aligning the reads to the final contigs and using those alignments to infer edges between the contigs. This defaults to false.</p>
<p><strong><code>-Q, --quality-offset INT</code></strong></p>
<p>The <em>phred</em> encoding offset. In most cases, MHM2 will be able to detect this offset from analyzing the reads file, so it usually does not need to be explicitly set.</p>
<p><strong><code>--progress BOOL</code></strong></p>
<p>If true, many time-consuming stages will be shown updating with a simple progress bar. The progress bar output will not be written into the log file, <code>mhm2.log</code>.</p>
<p><strong><code>-v, --verbose BOOL</code></strong></p>
<p>If true, MMHM2 will produce verbose output, which prints out a lot of additional information about timing of the run and the various computations that are being performed. This defaults to false. All of the information seen in verbose mode will always be written to the log file, <code>mhm2.log</code>.</p>
<p><strong><code>--config CONFIG_FILE_NAME</code></strong></p>
<p>If this is specified, the options will be loaded from a config file. The file is of the format:</p>
<p><code>key = value</code></p>
<p>where <code>key</code> is the name of an option and <code>value</code> is the value of the option. All blank lines and lines beginning with a semi-colon will be ignored. When the config file is not specified as an option, MHM2 always writes out all the options in the file <code>mhm2.config</code>.</p>
<p>Even when options are loaded from a config file, they can still be overridden by options on the command line. For example, if the config file, <code>test.config</code>, contains the line:</p>
<p><code>k = 21,33,55,77,99</code></p>
<p>but the command line is:</p>
<p><code>mhm2.py --config test.config -k 45,63</code></p>
<p>then MHM2 will run with <em>k</em>-mer lengths of 45 and 63.</p>
<h2 id="advanced-options">Advanced options</h2>
<p>These are additional options for tuning performance or the quality of the output, or selecting precisely how to restart a run. Most users will not need any of these options.</p>
<h3 id="restarting-runs">Restarting runs</h3>
<p>Although the <code>--restart</code> option provides for simple restarts of previous runs, it is possible to restart at very specific points, with new options, e.g. restarting scaffolding with different <em>k</em>-mer values, set using the <code>-s</code> option.</p>
<p>The relevant options are listed below.</p>
<p><strong><code>-c, --contigs STRING</code></strong></p>
<p>The file name containing contigs in FASTA format that are to be used as the most recent checkpoint for a restart. Any contigs file generated during a checkpointed run can be used, so it is possible to restart at any stage.</p>
<p><strong><code>--max-kmer-len INT</code></strong></p>
<p>The maximum <em>k</em>-mer length used in contigging. This is usually derived from the parameters, and so only needs to be specified if the restart is only scaffolding rounds, and no contigging rounds. For example, the following command will restart after the scaffolding round with <code>k=99</code> and will run run two more scaffolding rounds with <code>k=55</code> and <code>k=21</code>:</p>
<p><code>mhm2.py -o outdir -r reads.fq -c scaff-contigs-99.fasta --max-kmer-len 99 -s 55,21</code></p>
<p><strong><code>--prev-kmer-len K</code></strong></p>
<p>The <em>k</em>-mer length in the previous contigging round. Only needed if restarting in contigging, e.g.</p>
<p><code>mhm2.py -o outdir -r reads.fq -c contigs-77.fasta --max-prev-kmer-len 55</code></p>
<h3 id="tuning-assembly-quality">Tuning assembly quality</h3>
<p>There are several options for adjusting the quality, apart from the <em>k</em>-mer values specified for the contigging and scaffolding rounds, as described earlier.</p>
<p><strong><code>--break-scaff-Ns INT</code></strong></p>
<p>The number of Ns allowed in a gap before the scaffold is broken into two. The default is 10.</p>
<p><strong><code>--min-depth-thres INT</code></strong></p>
<p>The minimum depth (abundance) for a <em>k</em>-mer to be considered for the deBruijn graph traversal. This defaults to 2. Increasing it can reduce errors at the cost of reduced contiguity and genome discovery.</p>
<h3 id="adjusting-performance-and-memory-usage">Adjusting performance and memory usage</h3>
<p>There are several options that adjust the trade-off between the memory used and the time taken, or that influence the performance in different ways on different platforms.</p>
<p><strong><code>--max-kmer-store INT</code></strong></p>
<p>The maximum size per process for the <em>k</em>-mer store, in MB. This defaults to 1% of available memory. Higher values use more memory, but with potentially faster computation.</p>
<p><strong><code>--max-rpcs-in-flight INT</code></strong></p>
<p>The maximum number of remote procedure calls (RPCs) outstanding at a time. This reduces memory usage but increases running time. It defaults to 100, and is interpreted as unlimited if this is set to 0.</p>
<p><strong><code>--use-heavy-hitters BOOL</code></strong></p>
<p>Activate code for managing <em>heavy hitters</em>, which are <em>k</em>-mers that occur far more frequently than any others. This can improve performance for datasets that have a few <em>k</em>-mers with extremely high abundance. Defaults to false.</p>
<p><strong><code>--ranks-per-gpu INT</code></strong></p>
<p>When GPUs are used, this overrides the automatic detection of how many processes use each GPU. It can be used to explicitly to tune for specific configurations of CPU/GPUs. This defaults to 0 if there are no GPUs available; otherwise it is automatically calculated.</p>
<p><strong><code>--force-bloom BOOL</code></strong></p>
<p>Always use bloom filters when analyzing <em>k</em>-mers. Bloom filters reduce memory usage and MHM2 determines if they are necessary by computing the available memory before doing the <em>k</em>-mer analysis. However, it is possible to force MHM2 to always use as little memory as possible by setting this option to true. It defaults to false.</p>
<p><strong><code>--pin STRING</code></strong></p>
<p>Restrict the hardware contexts that processes can run on. There are 4 options: <code>cpu</code>, meaning restrict each process to a single logical CPU; <code>core</code>, meaning restrict each process to a core; <code>numa</code>, meaning restrict each process to a NUMA domain; and <code>none</code>, meaning don’t restrict the processes. By default, it restricts to <code>cpu</code>.</p>
<p><strong><code>--shared-heap INT</code></strong></p>
<p>Set the shared heap size used by the UPC++ runtime, as a percentage of the available memory. This is automatically set and should never need to be adjusted. However, there may be some rare cases on certain hardware where this needs to be adjusted to enable MHM2 to run without memory errors. This defaults to 10%.</p>
<p><strong><code>--procs INT</code></strong></p>
<p>Set the number of processes for MHM2 to run with. By default, MHM2 automatically detects the number of available processes and runs on all of them. This setting allows a user to run MHM2 on a subset of available processors, which may be desirable if running on a server that is running other applications.</p>
</body>
</html>
